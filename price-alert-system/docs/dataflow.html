<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Price Alert System — Data Flow Visualization</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body { font-family: 'Segoe UI', system-ui, -apple-system, sans-serif; background: #0d1117; color: #c9d1d9; overflow-x: hidden; }

  header { text-align: center; padding: 24px 16px 8px; }
  header h1 { font-size: 22px; font-weight: 600; color: #e6edf3; }
  header p { font-size: 13px; color: #7d8590; margin-top: 4px; }

  .controls { display: flex; justify-content: center; gap: 10px; padding: 12px 16px 20px; flex-wrap: wrap; }
  .controls button {
    padding: 8px 18px; border: 1px solid #30363d; border-radius: 6px;
    background: #161b22; color: #c9d1d9; font-size: 13px; cursor: pointer;
    transition: all .15s;
  }
  .controls button:hover { background: #1f2937; border-color: #58a6ff; }
  .controls button.active { background: #1f6feb; border-color: #1f6feb; color: #fff; }
  .controls .speed { font-size: 12px; color: #7d8590; display: flex; align-items: center; gap: 6px; }
  .controls .speed input { width: 80px; accent-color: #1f6feb; }

  .canvas-wrap { position: relative; width: 100%; max-width: 1100px; margin: 0 auto; padding: 0 16px; }
  canvas { display: block; width: 100%; height: auto; border-radius: 8px; }

  .legend { display: flex; justify-content: center; gap: 20px; padding: 16px; flex-wrap: wrap; }
  .legend-item { display: flex; align-items: center; gap: 6px; font-size: 12px; color: #7d8590; }
  .legend-dot { width: 10px; height: 10px; border-radius: 50%; }

  .step-info {
    max-width: 700px; margin: 0 auto; padding: 16px 20px; min-height: 80px;
    background: #161b22; border: 1px solid #30363d; border-radius: 8px;
    text-align: center; transition: opacity .2s;
  }
  .step-info h3 { font-size: 15px; color: #58a6ff; margin-bottom: 6px; }
  .step-info p { font-size: 13px; color: #8b949e; line-height: 1.5; }
  .step-info code { background: #1f2937; padding: 2px 6px; border-radius: 3px; font-size: 12px; color: #7ee787; }

  footer { text-align: center; padding: 20px; font-size: 11px; color: #484f58; }
</style>
</head>
<body>

<header>
  <h1>Price Alert System — Happy Path Data Flow</h1>
  <p>Interactive visualization of the transactional outbox pattern across all services</p>
</header>

<div class="controls">
  <button id="btn-play" class="active">&#9654; Play</button>
  <button id="btn-pause">&#10074;&#10074; Pause</button>
  <button id="btn-reset">&#8634; Reset</button>
  <button id="btn-step">Step &rarr;</button>
  <div class="speed">
    <span>Speed:</span>
    <input id="speed" type="range" min="0.5" max="3" step="0.25" value="1">
    <span id="speed-val">1x</span>
  </div>
</div>

<div class="canvas-wrap">
  <canvas id="c" width="1100" height="620"></canvas>
</div>

<div class="legend">
  <div class="legend-item"><div class="legend-dot" style="background:#58a6ff"></div>Service</div>
  <div class="legend-item"><div class="legend-dot" style="background:#f0883e"></div>Kafka Topic</div>
  <div class="legend-item"><div class="legend-dot" style="background:#7ee787"></div>PostgreSQL Table</div>
  <div class="legend-item"><div class="legend-dot" style="background:#d2a8ff"></div>Outbox Table</div>
  <div class="legend-item"><div class="legend-dot" style="background:#ff7b72"></div>Active Message</div>
</div>

<div class="step-info" id="info">
  <h3>Ready</h3>
  <p>Press <strong>Play</strong> to watch the happy path: user creates an alert, market tick triggers it, notification is persisted.</p>
</div>

<footer>Price Alert System &mdash; Hexagonal Architecture with Transactional Outbox (namastack-outbox)</footer>

<script>
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
const info = document.getElementById('info');
const DPR = window.devicePixelRatio || 1;
let W, H;

function resize() {
  const rect = canvas.getBoundingClientRect();
  W = 1100; H = 620;
  canvas.width = W * DPR; canvas.height = H * DPR;
  canvas.style.width = W + 'px'; canvas.style.height = H + 'px';
  ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
}
resize();
window.addEventListener('resize', resize);

// ── Nodes ──
const nodes = {
  user:       { x: 60,  y: 100, w: 90,  h: 40, label: 'User',                color: '#8b949e', type: 'actor' },
  alertApi:   { x: 220, y: 80,  w: 120, h: 50, label: 'alert-api',           color: '#58a6ff', type: 'service' },
  alertsDb:   { x: 220, y: 190, w: 120, h: 36, label: 'alerts',              color: '#7ee787', type: 'db' },
  outboxApi:  { x: 220, y: 250, w: 120, h: 36, label: 'alertapi_outbox',     color: '#d2a8ff', type: 'outbox' },
  kAlertChg:  { x: 440, y: 80,  w: 130, h: 36, label: 'alert-changes',       color: '#f0883e', type: 'kafka' },
  simulator:  { x: 60,  y: 400, w: 120, h: 40, label: 'market-simulator',    color: '#58a6ff', type: 'service' },
  ingestor:   { x: 220, y: 400, w: 120, h: 50, label: 'tick-ingestor',       color: '#58a6ff', type: 'service' },
  outboxIng:  { x: 220, y: 480, w: 120, h: 36, label: 'ingestor_outbox',     color: '#d2a8ff', type: 'outbox' },
  kTicks:     { x: 440, y: 400, w: 130, h: 36, label: 'market-ticks',        color: '#f0883e', type: 'kafka' },
  evaluator:  { x: 660, y: 240, w: 120, h: 50, label: 'evaluator',           color: '#58a6ff', type: 'service' },
  evalIndex:  { x: 660, y: 160, w: 120, h: 36, label: 'in-memory index',     color: '#3fb950', type: 'mem' },
  outboxEval: { x: 660, y: 340, w: 120, h: 36, label: 'evaluator_outbox',    color: '#d2a8ff', type: 'outbox' },
  kTriggers:  { x: 860, y: 240, w: 130, h: 36, label: 'alert-triggers',      color: '#f0883e', type: 'kafka' },
  notifier:   { x: 860, y: 380, w: 130, h: 50, label: 'notification-persister', color: '#58a6ff', type: 'service' },
  notifDb:    { x: 860, y: 480, w: 130, h: 36, label: 'notifications',       color: '#7ee787', type: 'db' },
  trigLogDb:  { x: 860, y: 540, w: 130, h: 36, label: 'alert_trigger_log',   color: '#7ee787', type: 'db' },
  apiNotif:   { x: 980, y: 100, w: 90,  h: 40, label: 'GET /notifications',  color: '#8b949e', type: 'actor' },
};

// ── Steps ──
const steps = [
  { from: 'user', to: 'alertApi', label: 'POST /alerts', desc: 'User creates alert', detail: 'User sends <code>POST /api/v1/alerts</code> with <code>{"symbol":"AAPL","thresholdPrice":150,"direction":"ABOVE"}</code>. JWT token authenticates the request.' },
  { from: 'alertApi', to: 'alertsDb', label: 'INSERT alert', desc: 'Alert persisted to DB', detail: 'AlertCommandHandler wraps in <code>@Transactional</code>. AlertService generates ULID, saves to <code>alerts</code> table with status <code>ACTIVE</code>.' },
  { from: 'alertApi', to: 'outboxApi', label: 'outbox.schedule()', desc: 'CREATED event written to outbox', detail: 'Within the SAME transaction, <code>AlertChangePublisher.publish()</code> calls <code>outbox.schedule(alertChange, "AAPL")</code>. Written to <code>alertapi_outbox_record</code>. DB commit = both alert + outbox record are atomic.' },
  { from: 'outboxApi', to: 'kAlertChg', label: 'poller → Kafka', desc: 'Outbox poller publishes to Kafka', detail: 'Namastack outbox poller picks up the record. <code>AlertChangeOutboxHandler.handle()</code> sends to <code>alert-changes</code> topic keyed by symbol. Record marked COMPLETED.' },
  { from: 'kAlertChg', to: 'evaluator', label: 'consume CREATED', desc: 'Evaluator receives alert change', detail: '<code>AlertChangeConsumer.onAlertChange()</code> receives the CREATED event. Routes to <code>handleCreated()</code> which builds an <code>AlertEntry</code>.' },
  { from: 'evaluator', to: 'evalIndex', label: 'addAlert()', desc: 'Alert indexed in memory', detail: '<code>AlertIndexManager.getOrCreate("AAPL")</code> returns a <code>SymbolAlertIndex</code>. The alert (ABOVE $150) is added to the TreeMap. Ready for evaluation.' },
  { from: 'simulator', to: 'ingestor', label: 'WebSocket tick', desc: 'Simulator sends market tick', detail: 'Market feed simulator generates a random-walk tick: <code>{"symbol":"AAPL","price":184.48,...}</code>. Sent via WebSocket to tick-ingestor.' },
  { from: 'ingestor', to: 'outboxIng', label: 'outbox.schedule()', desc: 'Tick written to ingestor outbox', detail: '<code>TickKafkaProducer.send()</code> parses JSON, validates type=TICK, calls <code>outbox.schedule(tick, "AAPL")</code>. Written to <code>ingestor_outbox_record</code> within a <code>@Transactional</code> boundary.' },
  { from: 'outboxIng', to: 'kTicks', label: 'poller → Kafka', desc: 'Tick published to Kafka', detail: 'Ingestor outbox poller (500ms interval, batch 100) picks up tick. <code>TickOutboxHandler.handle()</code> sends to <code>market-ticks</code> topic keyed by symbol.' },
  { from: 'kTicks', to: 'evaluator', label: 'consume tick', desc: 'Evaluator receives market tick', detail: '<code>MarketTickConsumer.onMarketTick()</code> receives AAPL tick at $184.48. Calls <code>evaluationEngine.evaluate("AAPL", 184.48, ...)</code>.' },
  { from: 'evaluator', to: 'evalIndex', label: 'evaluate()', desc: 'Alert fires! Price above threshold', detail: '<code>SymbolAlertIndex.evaluate(184.48)</code>: ABOVE alerts with threshold &le; 184.48 fire. Our $150 alert fires. Returns <code>AlertTrigger</code> with triggerPrice=$184.48.' },
  { from: 'evaluator', to: 'outboxEval', label: 'outbox.schedule()', desc: 'Trigger event written to outbox', detail: '<code>AlertTriggerProducer.send()</code> calls <code>outbox.schedule(trigger, userId)</code>. Written to <code>evaluator_outbox_record</code>. <code>AlertStatusUpdater.markTriggeredToday()</code> updates alert status to TRIGGERED_TODAY.' },
  { from: 'outboxEval', to: 'kTriggers', label: 'poller → Kafka', desc: 'Trigger published to Kafka', detail: 'Evaluator outbox poller picks up trigger. <code>AlertTriggerOutboxHandler.handle()</code> sends to <code>alert-triggers</code> topic keyed by userId. Record marked COMPLETED.' },
  { from: 'kTriggers', to: 'notifier', label: 'consume trigger', desc: 'Notification persister receives trigger', detail: '<code>AlertTriggerConsumer.onAlertTrigger()</code> receives the AlertTrigger event. Delegates to <code>NotificationPersistenceService.persist()</code>.' },
  { from: 'notifier', to: 'notifDb', label: 'INSERT idempotent', desc: 'Notification persisted (Layer 3 dedup)', detail: '<code>NotificationPort.insertIdempotent()</code> → <code>INSERT...ON CONFLICT (idempotency_key) DO NOTHING</code>. Key = <code>alertId:tradingDate</code>. First write wins.' },
  { from: 'notifier', to: 'trigLogDb', label: 'INSERT idempotent', desc: 'Trigger log persisted (Layer 4 dedup)', detail: '<code>AlertTriggerLogPort.insertIdempotent()</code> → <code>INSERT...ON CONFLICT (alert_id, trading_date) DO NOTHING</code>. Audit trail preserved.' },
  { from: 'apiNotif', to: 'notifDb', label: 'GET /notifications', desc: 'User retrieves notification', detail: 'User calls <code>GET /api/v1/notifications</code>. Returns paginated list sorted by <code>createdAt DESC</code>. Shows AAPL triggered at $184.48 above $150 threshold.' },
];

// ── Drawing helpers ──
function roundRect(x, y, w, h, r, fill, stroke) {
  ctx.beginPath();
  ctx.roundRect(x, y, w, h, r);
  if (fill) { ctx.fillStyle = fill; ctx.fill(); }
  if (stroke) { ctx.strokeStyle = stroke; ctx.lineWidth = 1.5; ctx.stroke(); }
}

function drawNode(n, highlight) {
  const glow = highlight ? 0.3 : 0;
  if (glow) {
    ctx.shadowColor = '#ff7b72'; ctx.shadowBlur = 16;
  }
  const bg = highlight ? '#1a2332' : '#0d1117';
  const border = highlight ? '#ff7b72' : n.color + '66';
  roundRect(n.x, n.y, n.w, n.h, 6, bg, border);
  ctx.shadowBlur = 0;

  ctx.fillStyle = highlight ? '#e6edf3' : n.color;
  ctx.font = n.type === 'service' ? 'bold 12px system-ui' : '11px system-ui';
  ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
  const icon = n.type === 'kafka' ? '  ' : n.type === 'db' ? '  ' : n.type === 'outbox' ? '  ' : n.type === 'mem' ? '  ' : '';
  ctx.fillText(icon + n.label, n.x + n.w / 2, n.y + n.h / 2);
}

function drawArrow(from, to, progress, label) {
  const fx = from.x + from.w / 2, fy = from.y + from.h / 2;
  const tx = to.x + to.w / 2, ty = to.y + to.h / 2;

  // Edge clipping
  const angle = Math.atan2(ty - fy, tx - fx);
  const sx = from.x + from.w / 2 + Math.cos(angle) * (from.w / 2 + 4);
  const sy = from.y + from.h / 2 + Math.sin(angle) * (from.h / 2 + 4);
  const ex = to.x + to.w / 2 - Math.cos(angle) * (to.w / 2 + 4);
  const ey = to.y + to.h / 2 - Math.sin(angle) * (to.h / 2 + 4);

  // Line
  ctx.beginPath(); ctx.moveTo(sx, sy); ctx.lineTo(ex, ey);
  ctx.strokeStyle = '#30363d'; ctx.lineWidth = 1; ctx.stroke();

  // Arrowhead
  const aLen = 8, aAng = 0.4;
  const a2 = Math.atan2(ey - sy, ex - sx);
  ctx.beginPath();
  ctx.moveTo(ex, ey);
  ctx.lineTo(ex - aLen * Math.cos(a2 - aAng), ey - aLen * Math.sin(a2 - aAng));
  ctx.moveTo(ex, ey);
  ctx.lineTo(ex - aLen * Math.cos(a2 + aAng), ey - aLen * Math.sin(a2 + aAng));
  ctx.strokeStyle = '#484f58'; ctx.lineWidth = 1.5; ctx.stroke();

  // Animated dot
  if (progress !== undefined && progress >= 0 && progress <= 1) {
    const dx = sx + (ex - sx) * progress;
    const dy = sy + (ey - sy) * progress;
    ctx.beginPath(); ctx.arc(dx, dy, 5, 0, Math.PI * 2);
    ctx.fillStyle = '#ff7b72'; ctx.fill();
    ctx.shadowColor = '#ff7b72'; ctx.shadowBlur = 12;
    ctx.beginPath(); ctx.arc(dx, dy, 5, 0, Math.PI * 2);
    ctx.fillStyle = '#ff7b72'; ctx.fill();
    ctx.shadowBlur = 0;

    // Label near dot
    if (label) {
      ctx.fillStyle = '#e6edf3'; ctx.font = '10px system-ui';
      ctx.textAlign = 'center'; ctx.textBaseline = 'bottom';
      ctx.fillText(label, dx, dy - 10);
    }
  }
}

// ── Animation state ──
let currentStep = -1;
let stepProgress = 0;
let playing = true;
let speed = 1;
let lastTime = 0;
const STEP_DURATION = 2000; // ms per step

function setStep(i) {
  currentStep = Math.max(-1, Math.min(i, steps.length - 1));
  stepProgress = 0;
  updateInfo();
}

function updateInfo() {
  if (currentStep < 0 || currentStep >= steps.length) {
    info.innerHTML = '<h3>Ready</h3><p>Press <strong>Play</strong> to watch the happy path.</p>';
    return;
  }
  const s = steps[currentStep];
  info.innerHTML = `<h3>Step ${currentStep + 1}/${steps.length}: ${s.desc}</h3><p>${s.detail}</p>`;
}

function draw(time) {
  const dt = time - lastTime;
  lastTime = time;

  ctx.clearRect(0, 0, W, H);

  // Draw all static edges (completed steps)
  for (let i = 0; i < steps.length; i++) {
    const s = steps[i];
    const from = nodes[s.from], to = nodes[s.to];
    if (i < currentStep) {
      drawArrow(from, to, -1);
    } else if (i === currentStep) {
      drawArrow(from, to, stepProgress, s.label);
    } else {
      drawArrow(from, to, -1);
    }
  }

  // Draw nodes
  for (const key in nodes) {
    const n = nodes[key];
    const active = currentStep >= 0 && currentStep < steps.length &&
      (steps[currentStep].from === key || steps[currentStep].to === key);
    drawNode(n, active);
  }

  // Step counter
  ctx.fillStyle = '#484f58'; ctx.font = '11px system-ui';
  ctx.textAlign = 'right'; ctx.textBaseline = 'top';
  if (currentStep >= 0) {
    ctx.fillText(`Step ${currentStep + 1} / ${steps.length}`, W - 10, 10);
  }

  // Advance animation
  if (playing && currentStep >= 0 && currentStep < steps.length) {
    stepProgress += (dt * speed) / STEP_DURATION;
    if (stepProgress >= 1.3) { // linger a bit after arrival
      if (currentStep < steps.length - 1) {
        currentStep++;
        stepProgress = 0;
        updateInfo();
      } else {
        playing = false;
        updateButtons();
      }
    }
  }

  requestAnimationFrame(draw);
}

function updateButtons() {
  document.getElementById('btn-play').classList.toggle('active', playing);
  document.getElementById('btn-pause').classList.toggle('active', !playing);
}

// ── Controls ──
document.getElementById('btn-play').onclick = () => {
  if (currentStep < 0 || currentStep >= steps.length - 1) setStep(0);
  playing = true; updateButtons();
};
document.getElementById('btn-pause').onclick = () => {
  playing = false; updateButtons();
};
document.getElementById('btn-reset').onclick = () => {
  playing = false; setStep(-1); updateButtons();
};
document.getElementById('btn-step').onclick = () => {
  playing = false;
  if (currentStep < steps.length - 1) setStep(currentStep + 1);
  else setStep(0);
  stepProgress = 1.0;
  updateButtons();
};
document.getElementById('speed').oninput = (e) => {
  speed = parseFloat(e.target.value);
  document.getElementById('speed-val').textContent = speed + 'x';
};

updateInfo();
requestAnimationFrame(draw);
</script>
</body>
</html>
